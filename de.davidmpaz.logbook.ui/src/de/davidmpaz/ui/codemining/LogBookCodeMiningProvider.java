/*
 * generated by Xtext 2.29.0
 */
package de.davidmpaz.ui.codemining;

import java.util.Iterator;
import java.util.List;

import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.codemining.ICodeMining;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.ui.codemining.AbstractXtextCodeMiningProvider;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.util.IAcceptor;

import com.google.inject.Inject;

import de.davidmpaz.logBook.Date;
import de.davidmpaz.logBook.LogEntry;
import de.davidmpaz.services.LogBookGrammarAccess;

@SuppressWarnings("restriction")
public class LogBookCodeMiningProvider extends AbstractXtextCodeMiningProvider {

	@Inject LogBookGrammarAccess grammarAccess;

	@Override
	protected void createCodeMinings(
			IDocument document,
			XtextResource resource,
			CancelIndicator indicator,
			IAcceptor<? super ICodeMining> acceptor
			) throws BadLocationException {
		addCodeMineForLogEntry(resource, acceptor);
	}

	/**
	 * Add code mining for log entry elements
	 *
	 * TODO Make this work
	 *
	 * @param resource
	 * @param acceptor
	 */
	private void addCodeMineForLogEntry(
			XtextResource resource,
			IAcceptor<? super ICodeMining> acceptor
			) {
		List<LogEntry> allEntries = EcoreUtil2.eAllOfType(resource.getContents().get(0), LogEntry.class);
		for(LogEntry entry : allEntries) {
			ICompositeNode node = NodeModelUtils.findActualNodeFor(entry);
			for(Iterator<INode> it = node.getAsTreeIterable().iterator(); it.hasNext();) {
				INode child  = it.next();
				if (child.getGrammarElement() instanceof Date) {
					float hours = getHours(entry);
					String annotationHour = hours > 1 ? hours + " Hours" : hours + " Hour";
					acceptor.accept(createNewLineContentCodeMining(child.getTotalOffset() + 1, annotationHour));
				}
			}
		}
	}

	private float getHours(LogEntry day) {
		float result = 1;
		return result;
	}
}
