/*
 * generated by Xtext 2.29.0
 */
package de.davidmpaz.ui.codemining;

import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.codemining.ICodeMining;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.impl.RuleCallImpl;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.ui.codemining.AbstractXtextCodeMiningProvider;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.util.IAcceptor;

import com.google.inject.Inject;

import de.davidmpaz.logBook.LogEntry;
import de.davidmpaz.logBook.Task;
import de.davidmpaz.services.LogBookGrammarAccess;

@SuppressWarnings("restriction")
public class LogBookCodeMiningProvider extends AbstractXtextCodeMiningProvider {

	@Inject LogBookGrammarAccess grammarAccess;

	@Override
	protected void createCodeMinings(
			IDocument document,
			XtextResource resource,
			CancelIndicator indicator,
			IAcceptor<? super ICodeMining> acceptor
			) throws BadLocationException {
		addCodeMineForLogEntry(resource, acceptor);
	}

	/**
	 * Add code mining for log entry elements
	 *
	 * TODO Make this work
	 *
	 * @param resource
	 * @param acceptor
	 */
	private void addCodeMineForLogEntry(
			XtextResource resource,
			IAcceptor<? super ICodeMining> acceptor
			) {
		List<LogEntry> allEntries = EcoreUtil2.eAllOfType(resource.getContents().get(0), LogEntry.class);
		for(LogEntry entry : allEntries) {
			ICompositeNode node = NodeModelUtils.findActualNodeFor(entry);
			for(Iterator<INode> it = node.getAsTreeIterable().iterator(); it.hasNext();) {
				INode child  = it.next();
				EObject element = child.getGrammarElement();
				boolean isDate = (element instanceof RuleCallImpl) &&
						((RuleCallImpl) element).getRule().getName().equals("Date");
				if (isDate) {
					float hours = getHours(entry);
					String annotationHour = hours > 1 ? hours + " Hours" : hours + " Hour";
					acceptor.accept(createNewLineContentCodeMining(child.getEndOffset() + 1, annotationHour));
				}
			}
		}
	}

	private float getHours(LogEntry day) {
		float result = 0;
		for (Task task : day.getTasks()) {
			result += Float.parseFloat(task.getTime().getValue() + "." + task.getTime().getDecimal());
		}
		return result;
	}
}
